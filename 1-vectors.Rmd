---
title: "Векторы"
author: "<i>Основы программирования на R</i><br><br>Антон Антонов"
output: 
  revealjs::revealjs_presentation:
    theme: serif
    highlight: tango
    center: false
    transition: fade
    pandoc_args: [ 
      "--slide-level", "1", 
      "--include-in-header", "custom.css"
    ]
---

```{r setup, echo=FALSE}
options(width = 110)
```

# О значении векторов
>- Вектор -- самая базовая структура данных в R
>- На векторах основаны более сложные структуры (матрица, список, фактор, дата фрейм)
>- Векторизация -- ключевая концепция языка

. . .

$$   
\begin{align}
  f: 
  \begin{bmatrix}
    x_{1} \\
    x_{2} \\
    \vdots \\
    x_{m}
  \end{bmatrix} 
  \longrightarrow
  \begin{bmatrix}
    f(x_{1}) \\
    f(x_{2}) \\
    \vdots \\
    f(x_{m})
  \end{bmatrix} 
\end{align}
$$

# Вектор
>- Вектор -- индексированный набор данных одного типа
>- R не делает различия между скалярными и векторными величинами, т.е. скаляр -- это вектор длины 1
>- Индексация векторов начинается с единицы (не с нуля!)
>- Для создания вектора можно использовать функцию `vector`

. . .

```{r}
x <- vector(length = 2)
x[1] <- 5
x[2] <- 8
x
```

# Создание векторов: функция `c`

. . .

Вместо поэлементного присваивания используют компактную запись:
```{r}
x <- c(5, 8)
x
```

. . .

Функция `c` может быть вложенной и принимать переменные:
```{r}
y <- c(x, 1, c(3, 4), x, NA)
y
```

# Создание векторов: оператор `:`

. . .

Создание числовых последовательностей с шагом 1:
```{r}
5:9
3:-1
```

# Создание векторов: функция `seq`

. . .

Более сложные последовательности:
```{r}
seq(1, 2, by = 0.25)
```

. . .

```{r}
seq(3, 4, length.out = 5)
```

. . .

```{r}
seq(3, 4, length = 5)
```

# Создание векторов: функция `rep`

. . .

Повторение векторов:
```{r}
rep(1:3, times = 3)
```

. . .

```{r}
rep(1:3, each = 4)
```

. . .

```{r}
rep(1:3, length.out = 5)
```

# Типы векторов
>- Атомарные (atomic) вектора: все элементы одного типа
>- Основные типы: 

. . .

  1. logical (TRUE/FALSE)
  2. integer (целые числа) 
  3. numeric/double (числа с плавающей точкой)
  4. complex (комплексные числа)
  5. character (строки)
  6. raw (байтовые последовательности)

# Типы векторов

. . .

Для определения типа вектора есть функции `typeof` и `is.*` (где `*` обозначает любой из типов)

. . .

```{r}
a <- c("Дуб - дерево", "Роза - цветок", "Воробей - птица")
typeof(a)
```

. . .

```{r}
is.character(a)
is.logical(a)
```

# Приведение типов

. . .

Естественным считается приведение слева направо по цепочке 

<center> logical --- integer --- double --- character </center>

. . .

```{r}
b <- c(FALSE, 1.5)
typeof(b)
```

. . .

```{r}
b <- c(5, b, "abc")
typeof(b)
```

. . .

```{r}
b
```

# Приведение типов

. . .

Принудительное приведение типов осуществляется функциями `as.*`:
```{r}
#as.double(b)
as.numeric(b)
```

. . .

```{r}
as.integer(b)
```

# Длина вектора: `length`

. . .

Помимо типа, у любого вектора есть длина:
```{r}
x <- 1:100
length(x)
```

. . .

Длина определяется автоматически, но её можно принудительно менять:
```{r}
length(x) <- 4; x
```

. . .

```{r}
length(x) <- 7; x
```

# Именованные вектора

. . .

Элементы вектора могут быть проименованы:
```{r}
a <- c(uno = 1, dos = 2, "universal answer" = 42, 99)
names(a)
```

. . .

```{r}
names(a) <- c("one", "two", "forty two", "ninety nine")
a
```

. . .

```{r}
#names(a) <- NULL
```

# Векторная арифметика

. . .

Арифметические операторы _векторизованы_ (применяются поэлементно):
```{r}
1:3 + c(-1, 2, 0)
```

. . .

```{r}
1:3 * c(-1, 2, 0)
```

. . .

```{r}
c(TRUE, TRUE, TRUE) & c(0, 1, 999)
```

# Векторизация

. . .

Многие функции в R имеют встроенную поддержку векторизации:
```{r}
# vectorized
sqrt(1:4)
```

. . .

```{r}
# vectorized
floor(seq(0, 3, by = 0.25))
```

. . .

```{r}
# not vectorized
sum(1:100)
```

# Правила переписывания (recycling)

. . .

Как работает арифметика на векторах разной длины?

. . .

1. Длина результата равна длине большего из векторов

. . .

2. Меньший вектор дублируется (переписывается) несколько раз, чтобы длина переписанного вектора совпала с длиной большего

. . .

3. Если длина большего вектора не делится нацело на длину меньшего, выдаётся предупреждение

. . .

```{r, eval = FALSE}
1:5 + 0:1
# recycling in action: (1, 2, 3, 4, 5) + (0, 1, 0, 1, 0) => (1, 3, 3, 5, 5)
```

. . .

```{r, echo = FALSE}
1:5 + 0:1
```

# Правила переписывания (recycling), cont.

. . .

Зачем это нужно?

. . .

```{r}
1:10 + 3
```

. . .

```{r}
(5:8) ^ 2 
```

. . .

```{r}
1:4 >= 3
```

# Доступ к элементам вектора

. . .

Рассмотрим простой вектор:
```{r}
x <- seq(10, 100, by = 10)
```

. . .

Чтение и запись элементов осуществляется при помощи оператора `[`:
```{r, eval = FALSE}
x[ind]
val <- x[ind]
x[ind] <- val
```

. . .

Для аргумента `ind` есть несколько правил. Тривиальный случай:
```{r}
x[]
```

# Положительные индексы

. . .

"Элементы с порядковыми номерами":
```{r}
x[1]
```

. . .

```{r}
x[3:4]
```

. . .

```{r}
x[c(8, 7, 3, 6:8, x[1])]
```

# Отрицательные индексы

. . .

"Все элементы, кроме указанных":

. . .

```{r}
x[-5]
```

. . .

```{r}
x[-(2:6)]
```

. . .

```{r}
x[c(-3, -5, -length(x), -5)]
```

# Логические индексы

. . .

"Элементы, соответствующие значению TRUE":
```{r}
x[rep(c(TRUE, FALSE), 5)]
```

. . .

```{r}
x[c(TRUE, FALSE)]
```

. . .

```{r}
x[x > 77 & x < 99]
```

# Индексация по имени

. . .

Для именованных векторов работает конструкция вида
```{r}
a[c("two", "one", "forty two")]
```

. . .

```{r}
a[c("forty two", "forty three", "forty four")]
```

# Функции `all` и `any`

. . .

```{r}
all(x < 200); all(x > 20)
```

. . .

```{r}
any(x > 150); any(x < 15)
```

# Функция `which`

. . .

```{r}
which(x >= 50)
```

. . .

```{r}
which.min(x)
which.max(x)
```


# Aтрибуты объектов

>- `length` -- это "свойство" объекта, оно есть всегда
>- _Атрибуты_ (`names`, `dimnames`, `dim`, ...) могут присутствовать, если это необходимо

. . .

```{r}
x <- c(5, 3, 9)
names(x) <- c("V", "III", "IX")
```

. . .

```{r}
attr(x, "author") <- "Caesar"
attributes(x)
```

. . .

```{r}
attributes(x) <- NULL
attributes(x)
```

# Глоссарий

. . .

`?c`, `?":"`, `?seq`, `?rep`

`?typeof`, `?is.logical`, `?as.logical`, etc.

`?length`, `?names`, recycling

`?"+"` (`?Arithmetic`), `?"["`

`?all`, `?any`

`?which`, `?which.min`, `?which.max`

`?attributes`


